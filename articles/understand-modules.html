<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv='X-UA-Compatible' content='IE=edge;chrome=1' />
    <meta name="viewport" content="initial-scale=1">


    <title>Blog Title - Understanding Node.js Modules</title>
    <link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/articles/feed.xml" />

    <link href="../stylesheets/normalize.css" rel="stylesheet" type="text/css" /><link href="../stylesheets/all.css" rel="stylesheet" type="text/css" /><link href="../stylesheets/blog.css" rel="stylesheet" type="text/css" /><link href="../stylesheets/github.css" rel="stylesheet" type="text/css" />
    <script src="../javascripts/all.js" type="text/javascript"></script>

  </head>
  <body id="articles">
    <nav class="navbar navbar-inverse navbar-default navbar-fixed-top">
      <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../"><i class="fa fa-diamond"></i></a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-inverse navbar-collapse" id="bs-example-navbar-collapse-1">
          <ul class="nav navbar-nav">
            <li><a href="../#projects">Projects</a></li>
            <li><a href="../#blog" class="selected">Articles</a></li>
            <li><a href="../#portfolio">Portfolio</a></liL>
            <li><a href="../#education">Education</a></liL>
            <li><a href="../#about">About</a></liL>
            <li><a href="../#contact">Contact</a></liL>
          </ul>
          <ul class="nav navbar-nav navbar-inverse navbar-right">
              <li><a href="https://github.com/ashlynbaum"><i class="fa fa-github-square fa-2x"></i></a></li>
              <li><a href="https://twitter.com/AshlynBaum"><i class="fa fa-twitter-square fa-2x"></i></a></li>
              <li><a href="https://nz.linkedin.com/pub/ashlyn-baum/46/b09/514"><i class="fa fa-linkedin-square fa-2x"></i></a></li>
          </ul>
        </div><!-- /.navbar-collapse -->
      </div><!-- /.container-fluid -->
    </nav>

    <!-- Jubotron -->
    <div id="header">
      <div class="jumbotron">
        <div class="row">
          <div class="col-xs-10 col-xs-offset-1">
            <h1>Ashlyn Baum</h1>
            <h2>Professional Problem Solver</h2>
          </div>
        </div>
      </div>
    </div>

    <div id="main" role="main">
      <div class="row">
        <div class="col-md-9">
          <div class="title">
            <h2>Understanding Node.js Modules</h2>
            <p class="blog-date">June 26, 2015</p>
          </div>
          <!-- Yield in blog articles -->
            <p>I have been working on a project using Node.js. With Node.js there are   so many options on how to organize your site, there are a few best practices out there but many things come down to personal preference. One thing that many people agree on, though, is to make it modular. Break your large applications up into many small independent working parts, or modules.</p>

<p>Typical trajectories for building an application is: monolith first, which is the approach I took. I started to build the back-end functionality of my application in one single file. This allowed me to recognize the hierarchy of  callbacks, see structure, and keep things organized in my mind. From there, I built integration tests which made refactoring easier. At that point, I could move the functionality of the application into individual self-contained files, known as modules.</p>

<h2 id="installing-modules">Installing modules</h2>

<p>You can include public modules hosted on Node Package Manager, <code>npm</code>, using the following command.</p>

<pre><code class="command-line">$ npm install name-of-module
</code></pre>

<p>To save the module in your <code>package.json</code> file:</p>

<pre><code class="command-line">$ npm install --save name-of-module
</code></pre>

<p>To save the module in <code>package.json</code> to only be required in your development environment:</p>

<pre><code class="command-line">$ npm install --save-dev name-of-module
</code></pre>

<p>Or you can write them yourself by exporting functionality of your code into small independent files. </p>

<p>When installing a public module with <code>npm</code>, it will go directly to your <code>node_module</code> directory. Make sure you ignore this directory from version control.</p>

<h2 id="comparing-javascript-modules-with-ruby-gems">Comparing JavaScript modules with Ruby gems</h2>

<p>Modules are great! They are easy to use and implement into your project. Node modules declare their dependencies, thus you cannot have version conflict issues. When compared to ruby gems, which do have version conflict issues, JavaScript modules&rsquo; independence can definitely be seen as an advantage. </p>

<p>The downside to the independence of JavaScript modules is that you have to declare every dependency in every file. This is makes using JavaScript modules less &lsquo;dry&rsquo; when compared to using Gems with Ruby. Gems use global variables to require everything once. Basically, with JavaScript modules you will end up writing slightly more code, but you will not have to deal with version conflicts.</p>

<h2 id="components-of-a-module">Components of a module</h2>

<p>There are three main parts to a module: what you require, your content, and what you export.</p>

<p>When calling <code>require()</code> in an application, it will return <code>module.exports</code>.</p>

<p>If you install modules from npm, then you will only have to worry about requiring the module. But if you would like to break your application up into small independent parts, then you will likely write your own modules.</p>

<h2 id="how-to-require-a-module">How to require a module</h2>

<p>If your module is in a <code>node_modules</code> directory you do not need to give the direct path name.</p>

<pre><code class="javascript">var helper = require(&#39;helpers&#39;);
</code></pre>

<p>The file structure will look something like this:</p>

<pre><code>/project-root
    /node_modles
        /helpers
    app.js
</code></pre>

<p>If your module is not in a <code>node_modules</code> directory. Add a <code>./</code> in front of the file or directory name to indicate the <code>helpers</code> directory is located on same level of the directory as the file it is being required in. If it is located one directory up then replace <code>./</code> with <code>../</code> and so on.</p>

<pre><code class="javascript">var helper = require(&#39;./helpers&#39;)
</code></pre>

<p>The file structure will look something like this:</p>

<pre><code>/project-root
    /node_modules
    /helpers
        index.js
    app.js
</code></pre>

<p>When including a directory like the <code>helpers</code> directory in the example above, as opposed to specifying a file, node will automatically load the <code>index.js</code> file within the required directory.</p>

<p>For further reading on file loading structure, check out the <a href="https://nodejs.org/docs/latest/api/modules.html#modules_file_modules">Node.js API</a>.</p>

<h2 id="using-file-structure-to-you-advantage">Using file structure to you advantage</h2>

<p>A simple trick so you do not have to include the <code>./</code> or and variation of your file path. Basically it comes down how you set up your directory structure.</p>

<pre><code>Root/
    node_modules/      &lt;-- npm installed modules
    sources/           &lt;-- sources becomes the new root of your application
        node_modules/  &lt;-- modules required privately by your application
        app.js
</code></pre>

<p>When you require a module, first node will look at the current level for the module, then in the <code>node_modules</code> directory. If it is not found in the first <code>node_modules</code> directory, then it will move up a directory in your application directory, and look for the module. Node will then look inside, this higher level <code>node_modules</code> directory to see if the modules live there. </p>

<p>Thus, when ever you require any module, it will look in both <code>node_modules</code> directories for your required module automatically. The need to preface <code>./</code> to describe the path to the module is not necessary if the modules live in either of the <code>node_modules</code> directories. </p>

<h2 id="different-exporting-patterns">Different exporting patterns</h2>

<p>There are three main ways to to export a module. The most common ways are to either export a function, an object, or a prototype. Exporting anonymously allows for simpler client interface; while named exports allow for more versatility when exporting because you have the ability to export more than one block. </p>

<h3 id="exporting-functions">Exporting functions</h3>

<p>With exporting a function, you can place the contents of your module in line with the export of the module.</p>

<h4 id="exporting-an-anonymous-function">Exporting an anonymous function</h4>

<pre><code class="javascript">// sample.js

module.exports = function (argument) {
  return argument.toString();
}
</code></pre>

<pre><code class="javascript">// app.js

var sample = require(&#39;sample&#39;);

sample(argument);
</code></pre>

<p>This method sets the anonymous function in the <code>sample.js</code> module equal to the variable <code>sample</code>. Then the function <code>sample</code> can be called within <code>app.js</code>.</p>

<h4 id="exporting-a-named-function">Exporting a named function</h4>

<pre><code class="javascript">// sample.js

exports.sample = function (argument) {
  return argument.toString();
}
</code></pre>

<pre><code class="javascript">// app.js

var sample = require(&#39;sample&#39;).sample;

sample(argument);
</code></pre>

<p>This method exports a function, but sets the function as a method on the <code>exports</code> variable.</p>

<h3 id="exporting-objects">Exporting objects</h3>

<h4 id="exporting-an-anonymous-object">Exporting an anonymous object</h4>

<pre><code class="javascript">// sample.js
var Sample = function () {};

Sample.prototype.string = function (argument) {
  return argument.toString();
};

module.exports = new Sample();
</code></pre>

<pre><code class="javascript">// app.js
var sample = require(&#39;sample&#39;);

sample.string(argument);
</code></pre>

<p>Another way to export an anonymous object be to just set the object equal to <code>module.exports</code>. View the routes example below to see this example in action.</p>

<pre><code class="javascript">module.exports = {};
</code></pre>

<h4 id="exporting-a-named-object">Exporting a named object</h4>

<p>Exporting a named object is very similar to exporting an anonymous object. The difference is analogous to the difference with exporting functions.</p>

<pre><code class="javascript">// sample.js
var Sample = function () {};

Sample.prototype.string = function (argument) {
  return argument.toString();
};

exports.Sample = new Sample();
</code></pre>

<pre><code class="javascript">// app.js
var sample = require(&#39;sample&#39;).Sample;

sample.string(argument);
</code></pre>

<h3 id="exporting-a-prototype">Exporting a prototype</h3>

<p>Exporting a prototype can be similar to exporting an object, where you create the instance of your object changes locations. When the prototype is exported, you must create the instance of of your object within your application.</p>

<h4 id="exporting-an-anonymous-prototype">exporting an anonymous prototype</h4>

<pre><code class="javascript">// sample.js
var Sample = function () {};

Sample.prototype.string = function (argument) {
  return argument.toString();
};

module.exports = Sample;
</code></pre>

<pre><code class="javascript">// app.js
var Sample = require(&#39;sample&#39;);
var sample = new Sample();
sample.string(argument);
</code></pre>

<h4 id="exporting-a-named-prototype">exporting a named prototype</h4>

<pre><code class="javascript">// sample.js
var Sample = function () {};

Sample.prototype.string = function (argument) {
  return argument.toString();
};

exports.Sample = Sample;
</code></pre>

<pre><code class="javascript">// app.js
var Sample = require(&#39;sample&#39;).Sample;
var sample = new Sample();
sample.string(argument);
</code></pre>

<h3 id="stay-away-form-exporting-global-variables">Stay away form exporting global variables</h3>

<p>Using global variables with Node.js makes the module no longer independent. In general, global variables will allow you to write the least amount of code, and add some magic to your application, but can create some conflicts in the future. </p>

<p>For example, the global variables that you define could already have been assigned within your program, and the conflict of variable assignment can create bugs within your application. It is best practice to define local variables and call the local variable when needed.</p>

<h2 id="modules-are-not-just-for-node.js.">Modules are not just for Node.js.</h2>

<p>You can use <a href="http://browserify.org/">browserify</a> to include modules to use in the browser. You can require modules the same way you would in node, but run them in the browser.</p>

<h2 id="example-defining-routes">Example defining routes</h2>

<p>In the example below, in the <code>index.js</code> file in the <code>/routes</code> directory, I export an anonymous object. Some people may name the <code>/routes</code> directory as a <code>/models</code> directory.</p>

<pre><code class="javascript">// routes/index.js

module.exports = {
  events: {
    create: require(&#39;./events/create&#39;)
   }
 };
</code></pre>

<p>Within the <code>app.js</code> file, I require the routes directory which will automatically include the <code>index.js</code> file located within <code>/routes</code>.</p>

<pre><code class="javascript">//app.js
var app = require(&#39;express&#39;)
var routes = require(&#39;./routes&#39;)

// database is defined outside of this example
var db = database

// Create Event
app.post(&#39;/events&#39;, routes.events.create(db));

</code></pre>

<p>The <code>index.js</code> file exports an anonymous object, that contains methods which require other modules. </p>

<p>In <code>app.js</code>, <code>routes.events.create(db)</code> calls an anonymous function located in the <code>create.js</code>, a file within the <code>routes</code> directory. The database <code>db</code> variable is sent in as an argument to <code>routes.create.events()</code> because it should only be defined once, not repeatedly inside each module.</p>

<pre><code class="javascript">//routes/events/create.js

module.exports = function(db){
  return function(req, res) {
    db.collection(&#39;events&#39;).insert( req.body, function(err, result) {
      if (err) { return console.log(err) };
      res.status(201);
    });
  }
}
</code></pre>

<hr>

<p>In conclusion, this has been a short introductory into using modules in your Node.js application. Happy hacking y&#39;all.</p>

        </div>
        <div class="col-md-3 sidebar">
          <aside>
            <h4>Recent Articles</h4>
            <ul class="list-unstyled">
                <li><a href="/articles/understand-modules.html">Understanding Node.js Modules</a></li>
                <li><a href="/articles/active-record.html">Active Record with Rails</a></li>
                <li><a href="/articles/favorite-podcasts.html">My podcasts picks</a></li>
                <li><a href="/articles/git-pull-vs-rebase.html">To merge or to rebase</a></li>
                <li><a href="/articles/event-handling-in-jquery.html">Event handling in jQuery</a></li>
            </ul>

            <h4>Categories</h4>
            <ul class="list-unstyled">
                <li><a href="/articles/javascript.html">JavaScript (2)</a></li>
                <li><a href="/articles/git.html">Git (1)</a></li>
                <li><a href="/articles/picks.html">Picks (1)</a></li>
                <li><a href="/articles/ruby-on-rails.html">Ruby on Rails (1)</a></li>
            </ul>

            <h4>By Year</h4>
            <ul class="list-unstyled">
                <li><a href="/articles/2015.html">2015 (5)</a></li>
            </ul>
          </aside>
        </div>
      </div>
    </div>
    <section id="footer">
      <div class="container-fluid">
        <div class="row">
          <p>
            <a href="https://github.com/ashlynbaum"><i class="fa fa-github-square fa-2x"></i></a>
            <a href="https://twitter.com/AshlynBaum"><i class="fa fa-twitter-square fa-2x"></i></a>
            <a href="https://nz.linkedin.com/pub/ashlyn-baum/46/b09/514"><i class="fa fa-linkedin-square fa-2x"></i></a>
          </p>
        </div>
      </div>
    </section>
    <script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-63369789-1', 'auto');
  ga('send', 'pageview');
</script>
  </body>
</html>
